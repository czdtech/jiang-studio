# 架构设计模式和最佳实践

## 架构模式

### 组件架构
- **页面组件**: 每个 AI 服务对应一个页面组件 (GeminiPage, OpenAIPage, KiePage)
- **模态框组件**: 独立的模态框组件处理特定功能 (EditorModal, ImagePreviewModal)
- **网格组件**: 可复用的图像展示组件 (ImageGrid, PortfolioGrid)
- **工具组件**: 通用 UI 组件 (Toast)

### 状态管理模式
- **本地状态**: 使用 useState 管理组件内部状态
- **自定义 Hook**: 复杂逻辑抽取为自定义 Hook (usePortfolio)
- **持久化存储**: 使用 IndexedDB 进行客户端数据持久化

### 服务层架构
- **API 服务**: 每个 AI 服务对应独立的服务模块
- **数据库服务**: 统一的 IndexedDB 操作接口
- **共享工具**: 通用工具函数集中管理

## 设计模式

### Provider Pattern
- 多个 AI 服务提供商的统一接口设计
- ProviderProfile 接口定义供应商配置结构
- 动态加载和切换不同供应商

### Factory Pattern
- 根据 scope 动态选择对应的 AI 服务
- 统一的图像生成和编辑接口

### Observer Pattern
- React 状态更新自动触发 UI 重渲染
- 作品集更新自动同步到 IndexedDB

## 最佳实践

### 错误处理
- 统一的错误处理机制
- 用户友好的错误提示
- API 调用失败的优雅降级

### 性能优化
- 图像 Base64 编码存储
- 懒加载和虚拟滚动 (如需要)
- 组件级别的状态管理避免不必要的重渲染

### 安全考虑
- API 密钥通过环境变量管理
- 客户端不直接暴露敏感信息
- 输入验证和清理

### 可维护性
- 清晰的文件结构和命名约定
- 类型安全的 TypeScript 代码
- 模块化的组件设计
- 统一的代码风格

### 用户体验
- 响应式设计适配不同设备
- 深色主题提供舒适的视觉体验
- 加载状态和进度指示
- 直观的操作流程和反馈

## 扩展指南

### 添加新的 AI 服务
1. 在 `services/` 目录创建新的服务模块
2. 在 `types.ts` 中添加相应的类型定义
3. 在 `components/` 中创建对应的页面组件
4. 在 `App.tsx` 中添加新的标签页

### 添加新功能
1. 确定功能所属的层级 (组件/服务/工具)
2. 遵循现有的命名和结构约定
3. 添加相应的 TypeScript 类型定义
4. 实现错误处理和用户反馈